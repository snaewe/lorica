// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html


// TAO_IDL - Generated from 
// be/be_codegen.cpp:703

#ifndef _TAO_IDL_TESTS_CPP_
#define _TAO_IDL_TESTS_CPP_


#include "testS.h"
#include "tao/PortableServer/Operation_Table_Perfect_Hash.h"
#include "tao/PortableServer/Upcall_Command.h"
#include "tao/PortableServer/Upcall_Wrapper.h"
#include "tao/TAO_Server_Request.h"
#include "tao/ORB_Core.h"
#include "tao/Profile.h"
#include "tao/Stub.h"
#include "tao/IFR_Client_Adapter.h"
#include "tao/Object_T.h"
#include "tao/AnyTypeCode/TypeCode.h"
#include "tao/AnyTypeCode/DynamicC.h"
#include "tao/CDR.h"
#include "tao/operation_details.h"
#include "tao/PortableInterceptor.h"
#include "tao/PortableServer/Basic_SArguments.h"
#include "tao/PortableServer/Object_SArgument_T.h"
#include "tao/PortableServer/Special_Basic_SArguments.h"
#include "tao/PortableServer/UB_String_SArguments.h"
#include "tao/PortableServer/Var_Size_SArgument_T.h"
#include "tao/PortableServer/TypeCode_SArg_Traits.h"
#include "tao/PortableServer/Object_SArg_Traits.h"
#include "tao/PortableServer/get_arg.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "ace/Dynamic_Service.h"
#include "ace/Malloc_Allocator.h"

#if !defined (__ACE_INLINE__)
#include "testS.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:976

#if !defined (_UNIONTEST_RESTRICTION__SARG_TRAITS_)
#define _UNIONTEST_RESTRICTION__SARG_TRAITS_
  
  template<>
  class SArg_Traits<UnionTest::Restriction>
    : public
        Var_Size_SArg_Traits_T<
            UnionTest::Restriction,
            TAO::Any_Insert_Policy_Stream <UnionTest::Restriction>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_UNIONTEST_RESTRICTIONCONTAINER__SARG_TRAITS_)
#define _UNIONTEST_RESTRICTIONCONTAINER__SARG_TRAITS_
  
  template<>
  class  SArg_Traits<UnionTest::RestrictionContainer>
    : public
        Object_SArg_Traits_T<
            UnionTest::RestrictionContainer_ptr,
            UnionTest::RestrictionContainer_var,
            UnionTest::RestrictionContainer_out,
            TAO::Any_Insert_Policy_Stream <UnionTest::RestrictionContainer_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:976

#if !defined (_UNIONTEST_RESTRICTION__ARG_TRAITS_)
#define _UNIONTEST_RESTRICTION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<UnionTest::Restriction>
    : public
        Var_Size_Arg_Traits_T<
            UnionTest::Restriction,
            TAO::Any_Insert_Policy_Stream <UnionTest::Restriction>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:141

#if !defined (_UNIONTEST_RESTRICTIONCONTAINER__ARG_TRAITS_)
#define _UNIONTEST_RESTRICTIONCONTAINER__ARG_TRAITS_
  
  template<>
  class  Arg_Traits<UnionTest::RestrictionContainer>
    : public
        Object_Arg_Traits_T<
            UnionTest::RestrictionContainer_ptr,
            UnionTest::RestrictionContainer_var,
            UnionTest::RestrictionContainer_out,
            TAO::Objref_Traits<UnionTest::RestrictionContainer>,
            TAO::Any_Insert_Policy_Stream <UnionTest::RestrictionContainer_ptr>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_interface.cpp:1549

class TAO_UnionTest_CommentRestriction_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /Users/colding/work/src/ACE_wrappers/apps/gperf/src/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_UnionTest_CommentRestriction_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_UnionTest_CommentRestriction_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18,  0,
     18, 18,  0,  5, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18,  0, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18,
#else
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18,  0, 18,  0, 18, 18,
      0,  5, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18,  0, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_UnionTest_CommentRestriction_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 17,
      HASH_VALUE_RANGE = 13,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_UnionTest::CommentRestriction::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_UnionTest::CommentRestriction::_component_skel, 0},
      {"",0,0},{"",0,0},
      {"_non_existent", &POA_UnionTest::CommentRestriction::_non_existent_skel, 0},
      {"_repository_id", &POA_UnionTest::CommentRestriction::_repository_id_skel, 0},
      {"_interface", &POA_UnionTest::CommentRestriction::_interface_skel, 0},
      {"",0,0},
      {"_get_message", &POA_UnionTest::CommentRestriction::_get_message_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_UnionTest_CommentRestriction_Perfect_Hash_OpTable tao_UnionTest_CommentRestriction_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_Initializer (size_t)
{
  UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_function_pointer = 
    UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
UnionTest__TAO_CommentRestriction_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_UnionTest::CommentRestriction::CommentRestriction (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_UnionTest_CommentRestriction_optable;
}

POA_UnionTest::CommentRestriction::CommentRestriction (const CommentRestriction& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_UnionTest::CommentRestriction::~CommentRestriction (void)
{
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_message_CommentRestriction
    : public TAO::Upcall_Command
  {
  public:
    inline _get_message_CommentRestriction (
      POA_UnionTest::CommentRestriction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->message ();
    }
  
  private:
    POA_UnionTest::CommentRestriction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_UnionTest::CommentRestriction::_get_message_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);

  _get_message_CommentRestriction command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_CommentRestriction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_CommentRestriction_Upcall_Command (
      POA_UnionTest::CommentRestriction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_UnionTest::CommentRestriction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::CommentRestriction::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);
  
  _is_a_CommentRestriction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_CommentRestriction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_CommentRestriction_Upcall_Command (
      POA_UnionTest::CommentRestriction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_UnionTest::CommentRestriction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::CommentRestriction::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);
  
  _non_existent_CommentRestriction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_CommentRestriction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_CommentRestriction_Upcall_Command (
      POA_UnionTest::CommentRestriction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_UnionTest::CommentRestriction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::CommentRestriction::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);
  
  _repository_id_CommentRestriction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_UnionTest::CommentRestriction::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_CommentRestriction_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_CommentRestriction_Upcall_Command (
      POA_UnionTest::CommentRestriction * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_UnionTest::CommentRestriction * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::CommentRestriction::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::CommentRestriction * const impl =
    static_cast<POA_UnionTest::CommentRestriction *> (servant);
  
  _get_component_CommentRestriction_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_UnionTest::CommentRestriction::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:UnionTest/CommentRestriction:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_UnionTest::CommentRestriction::_interface_repository_id (void) const
{
  return "IDL:UnionTest/CommentRestriction:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:902

void POA_UnionTest::CommentRestriction::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

UnionTest::CommentRestriction *
POA_UnionTest::CommentRestriction::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::UnionTest::CommentRestriction STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        UnionTest__TAO_CommentRestriction_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1549

class TAO_UnionTest_RestrictionContainer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /Users/colding/work/src/ACE_wrappers/apps/gperf/src/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_UnionTest_RestrictionContainer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_UnionTest_RestrictionContainer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16,  0,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16, 16,
      0,  5, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_UnionTest_RestrictionContainer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 6,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 11
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_UnionTest::RestrictionContainer::_is_a_skel, 0},
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_component", &POA_UnionTest::RestrictionContainer::_component_skel, 0},
      {"",0,0},
      {"_get_content", &POA_UnionTest::RestrictionContainer::_get_content_skel, 0},
      {"_non_existent", &POA_UnionTest::RestrictionContainer::_non_existent_skel, 0},
      {"_repository_id", &POA_UnionTest::RestrictionContainer::_repository_id_skel, 0},
      {"_interface", &POA_UnionTest::RestrictionContainer::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_UnionTest_RestrictionContainer_Perfect_Hash_OpTable tao_UnionTest_RestrictionContainer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_Initializer (size_t)
{
  UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_function_pointer = 
    UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
UnionTest__TAO_RestrictionContainer_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_UnionTest::RestrictionContainer::RestrictionContainer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_UnionTest_RestrictionContainer_optable;
}

POA_UnionTest::RestrictionContainer::RestrictionContainer (const RestrictionContainer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_UnionTest::RestrictionContainer::~RestrictionContainer (void)
{
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_content_RestrictionContainer
    : public TAO::Upcall_Command
  {
  public:
    inline _get_content_RestrictionContainer (
      POA_UnionTest::RestrictionContainer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::UnionTest::Restriction>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::UnionTest::Restriction> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_->content ();
    }
  
  private:
    POA_UnionTest::RestrictionContainer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_UnionTest::RestrictionContainer::_get_content_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::UnionTest::Restriction>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);

  _get_content_RestrictionContainer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_RestrictionContainer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_RestrictionContainer_Upcall_Command (
      POA_UnionTest::RestrictionContainer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_UnionTest::RestrictionContainer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::RestrictionContainer::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);
  
  _is_a_RestrictionContainer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_RestrictionContainer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_RestrictionContainer_Upcall_Command (
      POA_UnionTest::RestrictionContainer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_UnionTest::RestrictionContainer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::RestrictionContainer::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);
  
  _non_existent_RestrictionContainer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_RestrictionContainer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_RestrictionContainer_Upcall_Command (
      POA_UnionTest::RestrictionContainer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_UnionTest::RestrictionContainer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::RestrictionContainer::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);
  
  _repository_id_RestrictionContainer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_UnionTest::RestrictionContainer::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_RestrictionContainer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_RestrictionContainer_Upcall_Command (
      POA_UnionTest::RestrictionContainer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_UnionTest::RestrictionContainer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::RestrictionContainer::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::RestrictionContainer * const impl =
    static_cast<POA_UnionTest::RestrictionContainer *> (servant);
  
  _get_component_RestrictionContainer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_UnionTest::RestrictionContainer::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:UnionTest/RestrictionContainer:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_UnionTest::RestrictionContainer::_interface_repository_id (void) const
{
  return "IDL:UnionTest/RestrictionContainer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:902

void POA_UnionTest::RestrictionContainer::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

UnionTest::RestrictionContainer *
POA_UnionTest::RestrictionContainer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::UnionTest::RestrictionContainer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        UnionTest__TAO_RestrictionContainer_Proxy_Broker_Factory_function_pointer
      );
}

// TAO_IDL - Generated from
// be/be_interface.cpp:1549

class TAO_UnionTest_TestServer_Perfect_Hash_OpTable
  : public TAO_Perfect_Hash_OpTable
{
private:
  unsigned int hash (const char *str, unsigned int len);

public:
  const TAO_operation_db_entry * lookup (const char *str, unsigned int len);
};

/* C++ code produced by gperf version 2.8 (ACE version) */
/* Command-line: /Users/colding/work/src/ACE_wrappers/apps/gperf/src/gperf -m -M -J -c -C -D -E -T -f 0 -F 0,0 -a -o -t -p -K opname -L C++ -Z TAO_UnionTest_TestServer_Perfect_Hash_OpTable -N lookup  */
unsigned int
TAO_UnionTest_TestServer_Perfect_Hash_OpTable::hash (const char *str, unsigned int len)
{
  static const unsigned char asso_values[] =
    {
#if defined (ACE_MVS)
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16,  0,  5, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16,  0,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16,  0,  0, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16,  4, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16,
#else
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
     16, 16,  4, 16, 16, 16, 16, 16, 16, 16,
     16, 16, 16, 16, 16,  0, 16,  0, 16, 16,
      0,  5, 16, 16, 16, 16, 16, 16, 16, 16,
      0, 16, 16, 16, 16,  0,  0, 16, 16, 16,
     16, 16, 16, 16, 16, 16, 16, 16,
#endif /* ACE_MVS */
    };
  return len + asso_values[(int) str[len - 1]] + asso_values[(int) str[0]];
}

const TAO_operation_db_entry *
TAO_UnionTest_TestServer_Perfect_Hash_OpTable::lookup (const char *str, unsigned int len)
{
  enum
    {
      TOTAL_KEYWORDS = 7,
      MIN_WORD_LENGTH = 5,
      MAX_WORD_LENGTH = 14,
      MIN_HASH_VALUE = 5,
      MAX_HASH_VALUE = 15,
      HASH_VALUE_RANGE = 11,
      DUPLICATES = 0,
      WORDLIST_SIZE = 12
    };

  static const TAO_operation_db_entry  wordlist[] =
    {
      {"",0,0},{"",0,0},{"",0,0},{"",0,0},{"",0,0},
      {"_is_a", &POA_UnionTest::TestServer::_is_a_skel, 0},
      {"",0,0},{"",0,0},
      {"shutdown", &POA_UnionTest::TestServer::shutdown_skel, 0},
      {"",0,0},
      {"_component", &POA_UnionTest::TestServer::_component_skel, 0},
      {"",0,0},
      {"Restrict", &POA_UnionTest::TestServer::Restrict_skel, 0},
      {"_non_existent", &POA_UnionTest::TestServer::_non_existent_skel, 0},
      {"_repository_id", &POA_UnionTest::TestServer::_repository_id_skel, 0},
      {"_interface", &POA_UnionTest::TestServer::_interface_skel, 0},
    };

  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
    {
      unsigned int key = hash (str, len);

      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
        {
          const char *s = wordlist[key].opname;

          if (*str == *s && !strncmp (str + 1, s + 1, len - 1))
            return &wordlist[key];
        }
    }
  return 0;
}

static TAO_UnionTest_TestServer_Perfect_Hash_OpTable tao_UnionTest_TestServer_optable;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:958

TAO::Collocation_Proxy_Broker *
UnionTest__TAO_TestServer_Proxy_Broker_Factory_function ( ::CORBA::Object_ptr)
{
  return reinterpret_cast<TAO::Collocation_Proxy_Broker *> (0xdead); // Dummy
}

int
UnionTest__TAO_TestServer_Proxy_Broker_Factory_Initializer (size_t)
{
  UnionTest__TAO_TestServer_Proxy_Broker_Factory_function_pointer = 
    UnionTest__TAO_TestServer_Proxy_Broker_Factory_function;
  
  return 0;
}

static int
UnionTest__TAO_TestServer_Proxy_Broker_Stub_Factory_Initializer_Scarecrow =
  UnionTest__TAO_TestServer_Proxy_Broker_Factory_Initializer (
      reinterpret_cast<size_t> (UnionTest__TAO_TestServer_Proxy_Broker_Factory_Initializer)
    );

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:103

POA_UnionTest::TestServer::TestServer (void)
  : TAO_ServantBase ()
{
  this->optable_ = &tao_UnionTest_TestServer_optable;
}

POA_UnionTest::TestServer::TestServer (const TestServer& rhs)
  : TAO_Abstract_ServantBase (rhs),
    TAO_ServantBase (rhs)
{
}

POA_UnionTest::TestServer::~TestServer (void)
{
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class Restrict_TestServer
    : public TAO::Upcall_Command
  {
  public:
    inline Restrict_TestServer (
      POA_UnionTest::TestServer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::UnionTest::RestrictionContainer>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::UnionTest::RestrictionContainer> (
          this->operation_details_,
          this->args_,
          1);
        
      this->servant_->Restrict (
        arg_1);
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_UnionTest::TestServer::Restrict_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  TAO::SArg_Traits< ::UnionTest::RestrictionContainer>::in_arg_val _tao_restriction;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_restriction
    };
  
  static size_t const nargs = 2;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);

  Restrict_TestServer command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class shutdown_TestServer
    : public TAO::Upcall_Command
  {
  public:
    inline shutdown_TestServer (
      POA_UnionTest::TestServer * servant)
      : servant_ (servant)
    {
    }
    
    virtual void execute (void)
    {
      this->servant_->shutdown ();
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
  };
}


// TAO_IDL - Generated from 
// be/be_visitor_operation/operation_ss.cpp:190

void POA_UnionTest::TestServer::shutdown_skel (
    TAO_ServerRequest & server_request,
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< void>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);

  shutdown_TestServer command (
    impl);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}



// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:169

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _is_a_TestServer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _is_a_TestServer_Upcall_Command (
      POA_UnionTest::TestServer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      TAO::SArg_Traits< ::CORBA::Char *>::in_arg_type arg_1 =
        TAO::Portable_Server::get_in_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_,
          1);
        
      retval =
        this->servant_-> _is_a (
          arg_1);
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::TestServer::_is_a_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  TAO::SArg_Traits< ::CORBA::Char *>::in_arg_val _tao_repository_id;
  
  TAO::Argument * const args[] =
    {
      &retval,
      &_tao_repository_id
    };
  
  static size_t const nargs = 2;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);
  
  _is_a_TestServer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _non_existent_TestServer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _non_existent_TestServer_Upcall_Command (
      POA_UnionTest::TestServer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::ACE_InputCDR::to_boolean> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _non_existent ();
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::TestServer::_non_existent_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::ACE_InputCDR::to_boolean>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);
  
  _non_existent_TestServer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}
namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _repository_id_TestServer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _repository_id_TestServer_Upcall_Command (
      POA_UnionTest::TestServer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Char *>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Char *> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _repository_id ();
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::TestServer::_repository_id_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant)
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Char *>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);
  
  _repository_id_TestServer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

// TAO_IDL - Generated from 
// be/be_visitor_interface/interface_ss.cpp:508

void POA_UnionTest::TestServer::_interface_skel (
    TAO_ServerRequest & server_request, 
    void * /* servant_upcall */,
    void * servant)
{
  TAO_IFR_Client_Adapter *_tao_adapter =
    ACE_Dynamic_Service<TAO_IFR_Client_Adapter>::instance (
        TAO_ORB_Core::ifr_client_adapter_name ()
      );
    
  if (_tao_adapter == 0)
    {
      throw ::CORBA::INTF_REPOS (::CORBA::OMGVMCID | 1, ::CORBA::COMPLETED_NO);
    }
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);
  ::CORBA::InterfaceDef_ptr _tao_retval = impl->_get_interface ();
  server_request.init_reply ();
  TAO_OutputCDR &_tao_out = *server_request.outgoing ();
  
  ::CORBA::Boolean const _tao_result =
    _tao_adapter->interfacedef_cdr_insert (_tao_out, _tao_retval);
  
  _tao_adapter->dispose (_tao_retval);
  
  if (_tao_result == false)
    {
      throw ::CORBA::MARSHAL ();
    }
}

namespace POA_UnionTest
{
  
  
  // TAO_IDL - Generated from
  // be/be_visitor_operation/upcall_command_ss.cpp:136
  
  class _get_component_TestServer_Upcall_Command
    : public TAO::Upcall_Command
  {
  public:
    inline _get_component_TestServer_Upcall_Command (
      POA_UnionTest::TestServer * servant,
      TAO_Operation_Details const * operation_details,
      TAO::Argument * const args[])
      : servant_ (servant)
        , operation_details_ (operation_details)
        , args_ (args)
    {
    }
    
    virtual void execute (void)
    {
      TAO::SArg_Traits< ::CORBA::Object>::ret_arg_type retval =
        TAO::Portable_Server::get_ret_arg< ::CORBA::Object> (
          this->operation_details_,
          this->args_);
      
      retval =
        this->servant_-> _get_component ();
    }
  
  private:
    POA_UnionTest::TestServer * const servant_;
    TAO_Operation_Details const * const operation_details_;
    TAO::Argument * const * const args_;
  };
}


void POA_UnionTest::TestServer::_component_skel (
    TAO_ServerRequest & server_request, 
    void * TAO_INTERCEPTOR (servant_upcall),
    void * servant
  )
{
#if TAO_HAS_INTERCEPTORS == 1
  static ::CORBA::TypeCode_ptr const * const exceptions = 0;
  static ::CORBA::ULong const nexceptions = 0;
#endif /* TAO_HAS_INTERCEPTORS */
  
  TAO::SArg_Traits< ::CORBA::Object>::ret_val retval;
  
  TAO::Argument * const args[] =
    {
      &retval
    };
  
  static size_t const nargs = 1;
  
  POA_UnionTest::TestServer * const impl =
    static_cast<POA_UnionTest::TestServer *> (servant);
  
  _get_component_TestServer_Upcall_Command command (
    impl,
    server_request.operation_details (),
    args);
  
  TAO::Upcall_Wrapper upcall_wrapper;
  upcall_wrapper.upcall (server_request
                         , args
                         , nargs
                         , command
#if TAO_HAS_INTERCEPTORS == 1
                         , servant_upcall
                         , exceptions
                         , nexceptions
#endif  /* TAO_HAS_INTERCEPTORS == 1 */
                         );
}

::CORBA::Boolean POA_UnionTest::TestServer::_is_a (const char* value)
{
  return
    (
      !ACE_OS::strcmp (
          value,
          "IDL:UnionTest/TestServer:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    );
}

const char* POA_UnionTest::TestServer::_interface_repository_id (void) const
{
  return "IDL:UnionTest/TestServer:1.0";
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:902

void POA_UnionTest::TestServer::_dispatch (TAO_ServerRequest & req, void * servant_upcall)
{
  this->synchronous_upcall_dispatch (req, servant_upcall, this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_ss.cpp:852

UnionTest::TestServer *
POA_UnionTest::TestServer::_this (void)
{
  TAO_Stub *stub = this->_create_stub ();
  
  TAO_Stub_Auto_Ptr safe_stub (stub);
  ::CORBA::Object_ptr tmp = CORBA::Object_ptr ();
  
  ::CORBA::Boolean const _tao_opt_colloc =
    stub->servant_orb_var ()->orb_core ()->optimize_collocation_objects ();
  
  ACE_NEW_RETURN (
      tmp,
      ::CORBA::Object (stub, _tao_opt_colloc, this),
      0
    );
  
  ::CORBA::Object_var obj = tmp;
  (void) safe_stub.release ();
  
  typedef ::UnionTest::TestServer STUB_SCOPED_NAME;
  return
    TAO::Narrow_Utils<STUB_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        UnionTest__TAO_TestServer_Proxy_Broker_Factory_function_pointer
      );
}

#endif /* ifndef */

