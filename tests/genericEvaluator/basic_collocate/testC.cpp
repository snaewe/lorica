// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from
// be/be_codegen.cpp:381


#include "testC.h"
#include "tao/AnyTypeCode/Null_RefCount_Policy.h"
#include "tao/AnyTypeCode/TypeCode_Constants.h"
#include "tao/AnyTypeCode/Alias_TypeCode_Static.h"
#include "tao/AnyTypeCode/Objref_TypeCode_Static.h"
#include "tao/AnyTypeCode/Sequence_TypeCode_Static.h"
#include "tao/AnyTypeCode/String_TypeCode_Static.h"
#include "tao/AnyTypeCode/Struct_TypeCode_Static.h"
#include "tao/AnyTypeCode/TypeCode_Struct_Field.h"
#include "tao/AnyTypeCode/TypeCode_Case_T.h"
#include "tao/AnyTypeCode/Union_TypeCode_Static.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "tao/SystemException.h"
#include "tao/CDR.h"
#include "tao/AnyTypeCode/Any.h"
#include "tao/AnyTypeCode/Any_Impl_T.h"
#include "tao/AnyTypeCode/Any_Dual_Impl_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Object_Argument_T.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/AnyTypeCode/Any_Arg_Traits.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "testC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:73

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:868

#if !defined (_STRUCTURE__ARG_TRAITS_)
#define _STRUCTURE__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Structure>
    : public
        Var_Size_Arg_Traits_T<
            Structure,
            TAO::Any_Insert_Policy_Stream <Structure>
          >
  {
  };

#endif /* end #if !defined */
  
  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:976

#if !defined (_TEST_UNION__ARG_TRAITS_)
#define _TEST_UNION__ARG_TRAITS_
  
  template<>
  class Arg_Traits<Test_Union>
    : public
        Var_Size_Arg_Traits_T<
            Test_Union,
            TAO::Any_Insert_Policy_Stream <Test_Union>
          >
  {
  };

#endif /* end #if !defined */
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_DSI_LONGSEQ_CS_)
#define _DSI_LONGSEQ_CS_

DSI_LongSeq::DSI_LongSeq (void)
{}

DSI_LongSeq::DSI_LongSeq (
    ::CORBA::ULong max
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max)
{}

DSI_LongSeq::DSI_LongSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

DSI_LongSeq::DSI_LongSeq (
    const DSI_LongSeq &seq
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (seq)
{}

DSI_LongSeq::~DSI_LongSeq (void)
{}

void DSI_LongSeq::_tao_any_destructor (
    void * _tao_void_pointer
  )
{
  DSI_LongSeq * _tao_tmp_pointer =
    static_cast<DSI_LongSeq *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_typecode/alias_typecode.cpp:50



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_DSI_LongSeq_GUARD
#define _TAO_TYPECODE_DSI_LongSeq_GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        DSI_LongSeq_0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_long,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_DSI_LongSeq_0 =
        &DSI_LongSeq_0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_DSI_LongSeq_GUARD */

static TAO::TypeCode::Alias<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_DSI_LongSeq (
    ::CORBA::tk_alias,
    "IDL:DSI_LongSeq:1.0",
    "DSI_LongSeq",
    &TAO::TypeCode::tc_DSI_LongSeq_0);
  
::CORBA::TypeCode_ptr const _tc_DSI_LongSeq =
  &_tao_tc_DSI_LongSeq;

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84



// TAO_IDL - Generated from
// be/be_visitor_typecode/typecode_defn.cpp:516


#ifndef _TAO_TYPECODE_Structure__tao_seq_CORBA_Long__GUARD
#define _TAO_TYPECODE_Structure__tao_seq_CORBA_Long__GUARD

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

namespace TAO
{
  namespace TypeCode
  {
    namespace
    {
      TAO::TypeCode::Sequence< ::CORBA::TypeCode_ptr const *,
                              TAO::Null_RefCount_Policy>
        Structure__tao_seq_CORBA_Long__0 (
          ::CORBA::tk_sequence,
          &CORBA::_tc_long,
          0U);
        
      ::CORBA::TypeCode_ptr const tc_Structure__tao_seq_CORBA_Long__0 =
        &Structure__tao_seq_CORBA_Long__0;
    }
  }
}

TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_TYPECODE_Structure__tao_seq_CORBA_Long__GUARD */

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_Structure[] =
      {
        { "i", &CORBA::_tc_short },
        { "seq", &TAO::TypeCode::tc_Structure__tao_seq_CORBA_Long__0 },
        { "obj", &CORBA::_tc_Object }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_Structure (
  ::CORBA::tk_struct,
  "IDL:Structure:1.0",
  "Structure",
  _tao_fields_Structure,
  3);

::CORBA::TypeCode_ptr const _tc_Structure =
  &_tao_tc_Structure;

// TAO_IDL - Generated from 
// be/be_visitor_structure/structure_cs.cpp:66

void 
Structure::_tao_any_destructor (
    void *_tao_void_pointer
  )
{
  Structure *_tao_tmp_pointer =
    static_cast<Structure *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

// TAO_IDL - Generated from 
// be/be_visitor_sequence/sequence_cs.cpp:65

#if !defined (_STRUCTURE__TAO_SEQ_CORBA_LONG__CS_)
#define _STRUCTURE__TAO_SEQ_CORBA_LONG__CS_

Structure::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (void)
{}

Structure::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    ::CORBA::ULong max
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max)
{}

Structure::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

Structure::_tao_seq_CORBA_Long_::_tao_seq_CORBA_Long_ (
    const _tao_seq_CORBA_Long_ &seq
  )
  : TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (seq)
{}

Structure::_tao_seq_CORBA_Long_::~_tao_seq_CORBA_Long_ (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:91

Test_Union::Test_Union (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

Test_Union::Test_Union (const ::Test_Union &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    case 1:
    {
      typedef ::CORBA::Object_var OBJECT_FIELD;
      ACE_NEW (
          this->u_.obj_,
          OBJECT_FIELD ( ::CORBA::Object::_duplicate (u.u_.obj_->in ()))
        );
    }
    break;
    default:
    {
      this->u_.foo_ = ::CORBA::string_dup (u.u_.foo_);
    }
    break;
  }
}

Test_Union::~Test_Union (void)
{
  // Finalize.
  this->_reset ();
}

void Test_Union::_tao_any_destructor (void *_tao_void_pointer)
{
  Test_Union *tmp =
    static_cast<Test_Union *> (_tao_void_pointer);
  delete tmp;
}

Test_Union &
Test_Union::operator= (const ::Test_Union &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;
  
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.i_ = u.u_.i_;
    }
    break;
    case 1:
    {
      typedef ::CORBA::Object_var OBJECT_FIELD;
      ACE_NEW_RETURN (
          this->u_.obj_,
          OBJECT_FIELD ( ::CORBA::Object::_duplicate (u.u_.obj_->in ())),
          *this
        );
    }
    break;
    default:
    {
      this->u_.foo_ = ::CORBA::string_dup (u.u_.foo_);
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void Test_Union::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      break;
    case 1:
      delete this->u_.obj_;
      this->u_.obj_ = 0;
      break;
    default:
      ::CORBA::string_free (this->u_.foo_);
      this->u_.foo_ = 0;
      break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/union_typecode.cpp:60

static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_Union__0 (0, "i", &CORBA::_tc_short);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_Union__1 (1, "obj", &CORBA::_tc_Object);
static TAO::TypeCode::Case_T<CORBA::Short, char const *, ::CORBA::TypeCode_ptr const *> const _tao_cases_Test_Union__2 (-32768, "foo", &CORBA::_tc_string);

static TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const _tao_cases_Test_Union[] =
  {
    &_tao_cases_Test_Union__0,
    &_tao_cases_Test_Union__1,
    &_tao_cases_Test_Union__2
    
  };

static TAO::TypeCode::Union<char const *,
                            ::CORBA::TypeCode_ptr const *,
                            TAO::TypeCode::Case<char const *, ::CORBA::TypeCode_ptr const *> const * const *,
                            TAO::Null_RefCount_Policy>
  _tao_tc_Test_Union (
    "IDL:Test_Union:1.0",
    "Test_Union",
    &CORBA::_tc_short,
    _tao_cases_Test_Union,
    3, 2);
  
::CORBA::TypeCode_ptr const _tc_Test_Union =
  &_tao_tc_Test_Union;

// TAO_IDL - Generated from
// be/be_visitor_exception/exception_ctor.cpp:66

test_exception::test_exception (
    ::CORBA::Short _tao_error_code,
    const char * _tao_error_message,
    const char * _tao_status_message
  )
  : ::CORBA::UserException (
        "IDL:test_exception:1.0",
        "test_exception"
      )
{
  this->error_code = _tao_error_code;
  this->error_message = ::CORBA::string_dup (_tao_error_message);
  this->status_message = ::CORBA::string_dup (_tao_status_message);
}



// TAO_IDL - Generated from 
// be/be_visitor_exception/exception_cs.cpp:110

test_exception::test_exception (void)
  : ::CORBA::UserException (
        "IDL:test_exception:1.0",
        "test_exception"
      )
{
}

test_exception::~test_exception (void)
{
}

test_exception::test_exception (const ::test_exception &_tao_excp)
  : ::CORBA::UserException (
        _tao_excp._rep_id (),
        _tao_excp._name ()
      )
{
  this->error_code = _tao_excp.error_code;
  this->error_message = ::CORBA::string_dup (_tao_excp.error_message.in ());
  this->status_message = ::CORBA::string_dup (_tao_excp.status_message.in ());
}

test_exception&
test_exception::operator= (const ::test_exception &_tao_excp)
{
  this->::CORBA::UserException::operator= (_tao_excp);
  this->error_code = _tao_excp.error_code;
  this->error_message = ::CORBA::string_dup (_tao_excp.error_message.in ());
  this->status_message = ::CORBA::string_dup (_tao_excp.status_message.in ());
  return *this;
}

void test_exception::_tao_any_destructor (void *_tao_void_pointer)
{
  test_exception *_tao_tmp_pointer =
    static_cast<test_exception *> (_tao_void_pointer);
  delete _tao_tmp_pointer;
}

test_exception *
test_exception::_downcast ( ::CORBA::Exception *_tao_excp)
{
  return dynamic_cast<test_exception *> (_tao_excp);
}

const test_exception *
test_exception::_downcast ( ::CORBA::Exception const *_tao_excp)
{
  return dynamic_cast<const test_exception *> (_tao_excp);
}

::CORBA::Exception *test_exception::_alloc (void)
{
  ::CORBA::Exception *retval = 0;
  ACE_NEW_RETURN (retval, ::test_exception, 0);
  return retval;
}

::CORBA::Exception *
test_exception::_tao_duplicate (void) const
{
  ::CORBA::Exception *result = 0;
  ACE_NEW_RETURN (
      result,
      ::test_exception (*this),
      0
    );
  return result;
}

void test_exception::_raise (void) const
{
  throw *this;
}

void test_exception::_tao_encode (TAO_OutputCDR &cdr) const
{
  if (!(cdr << *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

void test_exception::_tao_decode (TAO_InputCDR &cdr)
{
  if (!(cdr >> *this))
    {
      throw ::CORBA::MARSHAL ();
    }
}

// TAO extension - the virtual _type method.
::CORBA::TypeCode_ptr test_exception::_tao_type (void) const
{
  return ::_tc_test_exception;
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/struct_typecode.cpp:84

static TAO::TypeCode::Struct_Field<
  char const *,
  ::CORBA::TypeCode_ptr const *> const 
    _tao_fields_test_exception[] =
      {
        { "error_code", &CORBA::_tc_short },
        { "error_message", &CORBA::_tc_string },
        { "status_message", &CORBA::_tc_string }
      };
  
static TAO::TypeCode::Struct<
  char const *,
  ::CORBA::TypeCode_ptr const *,
  TAO::TypeCode::Struct_Field<
    char const *,
    ::CORBA::TypeCode_ptr const *> const *,
  TAO::Null_RefCount_Policy>
_tao_tc_test_exception (
  ::CORBA::tk_except,
  "IDL:test_exception:1.0",
  "test_exception",
  _tao_fields_test_exception,
  3);

::CORBA::TypeCode_ptr const _tc_test_exception =
  &_tao_tc_test_exception;

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:60

// Traits specializations for Simple_Server.

Simple_Server_ptr
TAO::Objref_Traits<Simple_Server>::duplicate (
    Simple_Server_ptr p)
{
  return Simple_Server::_duplicate (p);
}

void
TAO::Objref_Traits<Simple_Server>::release (
    Simple_Server_ptr p)
{
  ::CORBA::release (p);
}

Simple_Server_ptr
TAO::Objref_Traits<Simple_Server>::nil (void)
{
  return Simple_Server::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<Simple_Server>::marshal (
    const Simple_Server_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// Function pointer for collocation factory initialization.
TAO::Collocation_Proxy_Broker * 
(*_TAO_Simple_Server_Proxy_Broker_Factory_function_pointer) (
    ::CORBA::Object_ptr obj
  ) = 0;

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

::CORBA::Short Simple_Server::s (
    void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Short>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_s",
      6,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

void Simple_Server::s (
    ::CORBA::Short s)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Short>::in_arg_val _tao_s (s);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_s
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_s",
      6,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

::CORBA::Boolean Simple_Server::any_test (
    const ::CORBA::Any & a)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::ACE_InputCDR::to_boolean>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Any>::in_arg_val _tao_a (a);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_a
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "any_test",
      8,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

::CORBA::Long Simple_Server::struct_test (
    ::CORBA::Long x,
    const ::Structure & the_in_structure,
    ::Structure_out the_out_structure,
    char *& name)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_x (x);
  TAO::Arg_Traits< ::Structure>::in_arg_val _tao_the_in_structure (the_in_structure);
  TAO::Arg_Traits< ::Structure>::out_arg_val _tao_the_out_structure (the_out_structure);
  TAO::Arg_Traits< ::CORBA::Char *>::inout_arg_val _tao_name (name);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_x,
      &_tao_the_in_structure,
      &_tao_the_out_structure,
      &_tao_name
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "struct_test",
      11,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

void Simple_Server::give_union (
    const ::Test_Union & arg)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::Test_Union>::in_arg_val _tao_arg (arg);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_arg
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "give_union",
      10,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

::CORBA::Object_ptr Simple_Server::echo_object (
    ::CORBA::Object_ptr obj)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< ::CORBA::Object>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Object>::in_arg_val _tao_obj (obj);
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_obj
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "echo_object",
      11,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
  
  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

void Simple_Server::raise_user_exception (
    void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  static TAO::Exception_Data
  _tao_Simple_Server_raise_user_exception_exceptiondata [] = 
    {
      {
        "IDL:test_exception:1.0",
        test_exception::_alloc
#if TAO_HAS_INTERCEPTORS == 1
        , _tc_test_exception
#endif /* TAO_HAS_INTERCEPTORS */
      }
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "raise_user_exception",
      20,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (
      _tao_Simple_Server_raise_user_exception_exceptiondata,
      1
    );
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

void Simple_Server::raise_system_exception (
    void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "raise_system_exception",
      22,
      this->the_TAO_Simple_Server_Proxy_Broker_
    );
  
  _tao_call.invoke (0, 0);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:78

void Simple_Server::shutdown (
    void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  if (this->the_TAO_Simple_Server_Proxy_Broker_ == 0)
    {
      Simple_Server_setup_collocation ();
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  
  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };
  
  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "shutdown",
      8,
      this->the_TAO_Simple_Server_Proxy_Broker_,
      TAO::TAO_ONEWAY_INVOCATION
    );
  
  _tao_call.invoke (0, 0);
}

Simple_Server::Simple_Server (void)
 : the_TAO_Simple_Server_Proxy_Broker_ (0)
{
  this->Simple_Server_setup_collocation ();
}

void
Simple_Server::Simple_Server_setup_collocation ()
{
  if (::_TAO_Simple_Server_Proxy_Broker_Factory_function_pointer)
    {
      this->the_TAO_Simple_Server_Proxy_Broker_ =
        ::_TAO_Simple_Server_Proxy_Broker_Factory_function_pointer (this);
    }
}

Simple_Server::~Simple_Server (void)
{}

void 
Simple_Server::_tao_any_destructor (void *_tao_void_pointer)
{
  Simple_Server *_tao_tmp_pointer =
    static_cast<Simple_Server *> (_tao_void_pointer);
  ::CORBA::release (_tao_tmp_pointer);
}

Simple_Server_ptr
Simple_Server::_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Simple_Server>::narrow (
        _tao_objref,
        "IDL:Simple_Server:1.0",
        _TAO_Simple_Server_Proxy_Broker_Factory_function_pointer
      );
}

Simple_Server_ptr
Simple_Server::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref
  )
{
  return
    TAO::Narrow_Utils<Simple_Server>::unchecked_narrow (
        _tao_objref,
        "IDL:Simple_Server:1.0",
        _TAO_Simple_Server_Proxy_Broker_Factory_function_pointer
      );
}

Simple_Server_ptr
Simple_Server::_duplicate (Simple_Server_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  
  return obj;
}

void
Simple_Server::_tao_release (Simple_Server_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
Simple_Server::_is_a (const char *value)
{
  if (
      !ACE_OS::strcmp (
          value,
          "IDL:Simple_Server:1.0"
        ) ||
      !ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        )
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* Simple_Server::_interface_repository_id (void) const
{
  return "IDL:Simple_Server:1.0";
}

::CORBA::Boolean
Simple_Server::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_typecode/objref_typecode.cpp:76

static TAO::TypeCode::Objref<char const *,
                             TAO::Null_RefCount_Policy>
  _tao_tc_Simple_Server (
    ::CORBA::tk_objref,
    "IDL:Simple_Server:1.0",
    "Simple_Server");
  
::CORBA::TypeCode_ptr const _tc_Simple_Server =
  &_tao_tc_Simple_Server;

// TAO_IDL - Generated from 
// be/be_visitor_sequence/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const DSI_LongSeq &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<DSI_LongSeq *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<DSI_LongSeq>::insert_copy (
        _tao_any,
        DSI_LongSeq::_tao_any_destructor,
        _tc_DSI_LongSeq,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    DSI_LongSeq *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<DSI_LongSeq>::insert (
      _tao_any,
      DSI_LongSeq::_tao_any_destructor,
      _tc_DSI_LongSeq,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    DSI_LongSeq *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const DSI_LongSeq *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const DSI_LongSeq *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<DSI_LongSeq>::extract (
        _tao_any,
        DSI_LongSeq::_tao_any_destructor,
        _tc_DSI_LongSeq,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_structure/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Structure &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Structure *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Structure>::insert_copy (
        _tao_any,
        Structure::_tao_any_destructor,
        _tc_Structure,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Structure *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Structure>::insert (
      _tao_any,
      Structure::_tao_any_destructor,
      _tc_Structure,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Structure *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Structure *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Structure *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Structure>::extract (
        _tao_any,
        Structure::_tao_any_destructor,
        _tc_Structure,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_union/any_op_cs.cpp:54


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const Test_Union &_tao_elem
  )
{
  if (0 == &_tao_elem) // Trying to de-reference NULL object
    _tao_any <<= static_cast<Test_Union *>( 0 ); // Use non-copying insertion of a NULL
  else
    TAO::Any_Dual_Impl_T<Test_Union>::insert_copy (
        _tao_any,
        Test_Union::_tao_any_destructor,
        _tc_Test_Union,
        _tao_elem
      );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    Test_Union *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<Test_Union>::insert (
      _tao_any,
      Test_Union::_tao_any_destructor,
      _tc_Test_Union,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    Test_Union *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const Test_Union *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const Test_Union *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<Test_Union>::extract (
        _tao_any,
        Test_Union::_tao_any_destructor,
        _tc_Test_Union,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from 
// be/be_visitor_exception/any_op_cs.cpp:50
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Dual_Impl_T<test_exception>::demarshal_value (
      TAO_InputCDR & cdr
    )
  {
    ::CORBA::String_var id;
    
    if (!(cdr >> id.out ()))
      {
        return false;
      }
    
    try
      {
        this->value_->_tao_decode (cdr);
      }
    catch (const ::CORBA::Exception &)
      {
        return false;
      }
    
    return true;
  }
}

// Copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    const test_exception &_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<test_exception>::insert_copy (
      _tao_any,
      test_exception::_tao_any_destructor,
      _tc_test_exception,
      _tao_elem
    );
}

// Non-copying insertion.
void operator<<= (
    ::CORBA::Any &_tao_any,
    test_exception *_tao_elem
  )
{
  TAO::Any_Dual_Impl_T<test_exception>::insert (
      _tao_any,
      test_exception::_tao_any_destructor,
      _tc_test_exception,
      _tao_elem
    );
}

// Extraction to non-const pointer (deprecated).
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    test_exception *&_tao_elem
  )
{
  return _tao_any >>= const_cast<
      const test_exception *&> (
      _tao_elem
    );
}

// Extraction to const pointer.
::CORBA::Boolean operator>>= (
    const ::CORBA::Any &_tao_any,
    const test_exception *&_tao_elem
  )
{
  return
    TAO::Any_Dual_Impl_T<test_exception>::extract (
        _tao_any,
        test_exception::_tao_any_destructor,
        _tc_test_exception,
        _tao_elem
      );
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/any_op_cs.cpp:51
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<>
  ::CORBA::Boolean
  Any_Impl_T<Simple_Server>::to_object (
      ::CORBA::Object_ptr &_tao_elem
    ) const
  {
    _tao_elem = ::CORBA::Object::_duplicate (this->value_);
    return true;
  }
}
TAO_END_VERSIONED_NAMESPACE_DECL


TAO_BEGIN_VERSIONED_NAMESPACE_DECL



/// Copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Simple_Server_ptr _tao_elem)
{
  Simple_Server_ptr _tao_objptr =
    Simple_Server::_duplicate (_tao_elem);
  _tao_any <<= &_tao_objptr;
}

/// Non-copying insertion.
void
operator<<= (
    ::CORBA::Any &_tao_any,
    Simple_Server_ptr *_tao_elem)
{
  TAO::Any_Impl_T<Simple_Server>::insert (
      _tao_any,
      Simple_Server::_tao_any_destructor,
      _tc_Simple_Server,
      *_tao_elem);
}

::CORBA::Boolean
operator>>= (
    const ::CORBA::Any &_tao_any,
    Simple_Server_ptr &_tao_elem)
{
  return
    TAO::Any_Impl_T<Simple_Server>::extract (
        _tao_any,
        Simple_Server::_tao_any_destructor,
        _tc_Simple_Server,
        _tao_elem);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_DSI_LongSeq_CPP_
#define _TAO_CDR_OP_DSI_LongSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const DSI_LongSeq &_tao_sequence
  )
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    DSI_LongSeq &_tao_sequence
  )
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_DSI_LongSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_Structure__tao_seq_CORBA_Long__CPP_
#define _TAO_CDR_OP_Structure__tao_seq_CORBA_Long__CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Structure::_tao_seq_CORBA_Long_ &_tao_sequence
  )
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Structure::_tao_seq_CORBA_Long_ &_tao_sequence
  )
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_Structure__tao_seq_CORBA_Long__CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:61


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Structure &_tao_aggregate
  )
{
  return
    (strm << _tao_aggregate.i) &&
    (strm << _tao_aggregate.seq) &&
    (strm << _tao_aggregate.obj.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Structure &_tao_aggregate
  )
{
  return
    (strm >> _tao_aggregate.i) &&
    (strm >> _tao_aggregate.seq) &&
    (strm >> _tao_aggregate.obj.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:67


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Test_Union &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.i ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.obj ();
      }
      break;
    default:
      {
        result = strm << _tao_union.foo ();
      }
      break;
  }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Test_Union &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;
  
  switch (_tao_discriminant)
  {
    case 0:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;
        
        if (result)
          {
            _tao_union.i (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        ::CORBA::Object_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();
        
        if (result)
          {
            _tao_union.obj (_tao_union_tmp.in ());
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();
        
        if (result)
          {
            _tao_union.foo (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_exception/cdr_op_cs.cpp:60
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const test_exception &_tao_aggregate
  )
{
  // First marshal the repository ID.
  if (strm << _tao_aggregate._rep_id ())
    {
      // Now marshal the members (if any).
      return (
        (strm << _tao_aggregate.error_code) &&
        (strm << _tao_aggregate.error_message.in ()) &&
        (strm << _tao_aggregate.status_message.in ())
       );
    }
  else
    {
      return false;
    }
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    test_exception &_tao_aggregate
  )
{
  // Demarshal the members.
  return (
    (strm >> _tao_aggregate.error_code) &&
    (strm >> _tao_aggregate.error_message.out ()) &&
    (strm >> _tao_aggregate.status_message.out ())
  );
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:63

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const Simple_Server_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    Simple_Server_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;
  
  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::Simple_Server RHS_SCOPED_NAME;
  
  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (
        obj.in (),
        _TAO_Simple_Server_Proxy_Broker_Factory_function_pointer
      );
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



